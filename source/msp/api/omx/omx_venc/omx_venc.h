/*========================================================================
Open MAX   Component: Video Encoder
This module contains the class definition for openMAX decoder component.
==========================================================================*/
#ifndef __OMX_VENC_H__
#define __OMX_VENC_H__

//khrons standard head file
#include "OMX_Component.h"
#include "OMX_Video.h"
#include "OMX_Custom.h"


#include "OMX_Types.h"

#include "hi_drv_venc.h"

#include "omx_allocator.h"
#include "omx_venc_queue.h"
#include "omx_venc_drv.h"

//specific-version NO.1.1
#define KHRONOS_1_1                                  //??
#define OMX_SPEC_VERSION			0x00000101       //æ±¾Åºê¶¨??

#define MAX_PORT_NUM				2

#define MAX_BUF_NUM					6//30

#define MAX_FRAME_WIDTH				720//1920
#define MAX_FRAME_HEIGHT			576//1088

#define DEFAULT_FPS				    30
#define DEFAULT_BITRATE             (2*1024*1024)
#define DEFAULT_ALIGN_SIZE			4096                      //?? ??Ëµ?Ðµ?4K?ß½??ß½??

#define DEF_MAX_IN_BUF_CNT			6
#define DEF_MIN_IN_BUF_CNT			6

#define DEF_MAX_OUT_BUF_CNT			4
#define DEF_MIN_OUT_BUF_CNT			1

#define OMX_VENC_COMP_NAME			"OMX.hisi.video.encoder"            //??Component_init???Ãµ?


#define OMX_COMPONENTROLES_H264		"video_encoder.avc"                //???Ú¸?pcomp_priv->m_role??Öµ        

#define OMX_COMPONENTROLES_H263		"video_encoder.h263"
#define OMX_COMPONENTROLES_MPEG2	"video_encoder.mpeg2"
#define OMX_COMPONENTROLES_MPEG4	"video_encoder.mpeg4"

#define BITS_PER_LONG				32
 
//#define ESHUTDOWN					108
//#define ERESTARTSYS					512

/*?????????????Ðµ? ?æ±¾?ÅºÍ½á¹¹??Ð¡*/
#define CONFIG_VERSION_SIZE(pParam,Type)  do{\
	pParam->nVersion.nVersion = OMX_SPEC_VERSION;\
	pParam->nSize             = sizeof(Type);\
    }while(0)


#define COUNTOF(x) (sizeof(x)/sizeof(x[0]))                  //?????????Ðº??Ðµ?Ôª?Ø¸???

#define MAX(a, b) ((a) > (b) ? (a) : (b))

#define OMX_CHECK_ARG_RETURN(a)  do{if ((a)){DEBUG_PRINT_ERROR("[%s]", __func__);return OMX_ErrorBadParameter;}}while(0)

#define ALIGN_UP(val, align) ( (val+((align)-1))&~((align)-1) )

#define FRAME_SIZE(w , h)  (((w) * (h) * 3) / 2)

// state transactions pending bits
#if 0
enum {                                   /*??componentË½?Ð½á¹¹?Ð£???Îª???Ö´????Ä±?Ö¾???????????Â¼??ó£¬°Ñ¸?bitÎ»?Ã»?0*/
	OMX_STATE_IDLE_PENDING				= 0x1,               //idle(????)?È´???Ö¾,?Ã±?Ö¾Îª1Ê±??????Ó¦?Â¼????íº¯???Ð´????ÃµÈ´??Ä²??÷£¬´????????Ñ¸?Î» ?Ã»?0         
	OMX_STATE_LOADING_PENDING			= 0x2,
	OMX_STATE_INPUT_ENABLE_PENDING		= 0x3,
	OMX_STATE_OUTPUT_ENABLE_PENDING		= 0x4,
	OMX_STATE_OUTPUT_DISABLE_PENDING	= 0x5,
	OMX_STATE_INPUT_DISABLE_PENDING		= 0x6,
	OMX_STATE_OUTPUT_FLUSH_PENDING		= 0x7,
	OMX_STATE_INPUT_FLUSH_PENDING		= 0x8,
	OMX_STATE_PAUSE_PENDING				= 0x9,
	OMX_STATE_EXECUTE_PENDING			= 0xA
};
#endif

// Deferred callback identifiers
/*enum {                                                        //???Ú±?Ê¾???? CMD ????,?Ô±??Ú²??????Ðµ?Ê±???Ð¶?Òª????Ï¢?Ä´?????Òª?????Ä¸?????
	OMX_GENERATE_COMMAND_DONE			= 0x1,                               
	OMX_GENERATE_FTB					= 0x2,
	OMX_GENERATE_ETB					= 0x3,
	OMX_GENERATE_COMMAND				= 0x4,
	OMX_GENERATE_EBD					= 0x5,
	OMX_GENERATE_FBD					= 0x6,
	OMX_GENERATE_FLUSH_INPUT_DONE		= 0x7,
	OMX_GENERATE_FLUSH_OUTPUT_DONE		= 0x8,
	OMX_GENERATE_START_DONE				= 0x9,
	OMX_GENERATE_PAUSE_DONE				= 0xA,
	OMX_GENERATE_RESUME_DONE			= 0xB,
	OMX_GENERATE_STOP_DONE				= 0xC,
	OMX_GENERATE_EOS_DONE				= 0xD,
	OMX_GENERATE_HARDWARE_ERROR			= 0xE,
	OMX_GENERATE_IMAGE_SIZE_CHANGE		= 0xF,
	OMX_GENERATE_CROP_RECT_CHANGE		= 0x10,
	OMX_GENERATE_UNUSED					= 0x11
};*/

enum {
	INPUT_PORT_INDEX	= 0,
	OUTPUT_PORT_INDEX	= 1
};

struct port_property {                                         //??Îª?Ë¿?Ë½?Ð½á¹¹?Ä³?Ô±??Á¿Ö®Ò»,?????Ë¶Ë¿?????
	OMX_U32 port_dir;                                     //?Ë¿ÚµÄ·???:in /out
	OMX_U32 min_count;                                    //??Ó¦?Ú±?×¼OMX_PARAM_PORTDEFINITIONTYPE???Í¶????Ðµ?nBufferCountMin??Á¿????Ê¶The minimum number of buffers this port requires
	OMX_U32 max_count;                                    //??Ó¦?Ú±?×¼OMX_PARAM_PORTDEFINITIONTYPE???Í¶????Ðµ?nBufferCountActual??Á¿????Ê¶The actual number of buffers allocated on this port
	OMX_U32 buffer_size;                                  //??Ó¦?Ú±?×¼OMX_PARAM_PORTDEFINITIONTYPE???Í¶????Ðµ?nBufferSize????Ê¶Size, in bytes, for buffers to be used for this channel
	OMX_U32 alignment;                                    //?????????Ú´?Ö®???Ä¶???!!4K????
};

/*struct omx_hisi_extern_index
{
	OMX_S8 index_name[OMX_MAX_STRINGNAME_SIZE];
	OMX_HISI_EXTERN_INDEXTYPE index_type;
};*/

struct codec_info {                                            //??????Ð­?????Í½á¹¹??,????????:
    const OMX_STRING role_name;                                     //????????????(uchar??????)
    OMX_VIDEO_CODINGTYPE compress_fmt;                         //OMX??×¼Í·?Ä¼?omx_video.h?Ð¶???????ÆµÐ­??Ã¶??????,???Õ¸?Öµ??OMX_COMPONENT_PRIVATE???Íµ?m_dec_fmt??OMX_VIDEO_PARAM_PORTFORMATTYPE??OMX_VIDEO_PORTDEFINITIONTYPE?????Ðµ?eCompressionFormat
	//enum venc_codec_type codec_type;                           //OMX??×¼Í·?Ä¼?omx_video.h?Ð¶???????ÆµÐ­??Ã¶??????,???Õ¸?Öµ??OMX_COMPONENT_PRIVATE???Íµ?drv_ctx.venc_chan_attr[VENC_MAX_CHN].chan_cfg.protocol,???å¶¨????hisi_venc.h??Ó¦??Ô­À´hi_unf_common.h?Ð¶???Ò»??                                    
    HI_UNF_VCODEC_TYPE_E codec_type;
};

struct codec_profile_level                                   //???ë²»??Òª? ??Ê±????
{
	OMX_S32 profile;
	OMX_S32 level;
};/**/


struct frame_info {                                          //?Ñ°????Ú±???Í¨????????
	OMX_U32 frame_width;
	OMX_U32 frame_height;
	OMX_U32 stride;
	//OMX_U32 scan_lines;
	//OMX_U32 crop_top;
	//OMX_U32 crop_left;
	//OMX_U32 crop_width;
	//OMX_U32 crop_height;
};/**/

// port private for omx
typedef struct OMX_PORT_PRIVATE {                               //?Ë¿Úµ?Ë½?Ð½á¹¹?å£¬??Îª??????Ë½?Ð½á¹¹???Ä³?Ô±Ö®Ò»????OMX_COMPONENT_PRIVATE?????Ð£???Ó¦????/?????Ë¿Ú¸???Ò»??
	OMX_BUFFERHEADERTYPE **m_omx_bufhead;                       //??Ó¦OMX??×¼???å£¬???Ú´??Å¸Ã¶Ë¿?Òª??????buffer
	//struct port_property port_pro;                              //?Ë¿????Ô½á¹¹?å£¬???Ð°????????Ý¶??Ú±?×¼?Ä¶Ë¿?????OMX_PARAM_PORTDEFINITIONTYPE?Ð¶?Ó¦

    OMX_PARAM_PORTDEFINITIONTYPE port_def;
	//OMX_U32	m_port_index;                                       //?Ë¿?ID??????   ??OMX_PARAM_PORTDEFINITIONTYPE?????Ð¶??å£»

    OMX_U32 m_buf_cnt;                                          //?àµ±?Ú±?Ê¶?Ë¿Úµ?i??buffer???????Ýµ?flag??m_buf_cnt??Ã¿Ò»Î»Îª1??????Î»??Ó¦?????Åµ?buffer?????Ý£????????Ð¶?port buffer ?Ä¿??????Ò¿?Ð´???Ä¿???buffer?È²???                                 

	OMX_U32 m_usage_bitmap;                                     //??????m_buf_cnt???Ã·????Æ£?Ö»???????? mark buffer to be allocated(??Ê¶?Ô¼????ëµ½??buffer???????Ôº???free????)
	OMX_U32	m_buf_pend_cnt;                                     //??Â¼???Ã»???????buffer??Ä¿(Êµ?????????Ú²??Ñ¾????????É£?Ö»?ÇµÈ´???Öª?Ã»?)~~??:fill_this_buffer_porxyÊ±++,??fill_this_buffer_doneÊ±--.

	//OMX_U32	m_port_enabled;                                     //?Ë¿?Ê¹?Ü±?Ö¾Î»??Ò²??Ó¦?Ú¶Ë¿Ú±?×¼????OMX_PARAM_PORTDEFINITIONTYPE?Ðµ?bEnabledÎ» 
	//OMX_U32	m_port_populated;                                   //?Ë¿Ú³???(?)??Ö¾Î»??Ò²??Ó¦?Ú¶Ë¿Ú±?×¼????OMX_PARAM_PORTDEFINITIONTYPE?Ðµ?bPopulatedÎ»????????????bPopulated??×¢?Í¡???Ê¾?Ë¿?????????buffer??Ä¿?Ñ¾??ïµ½??????

	OMX_BOOL m_port_reconfig;                                   //?Ë¿????????Ã±?Ö¾Î»??Ä¬??Îªfalse????????OMX_GENERATE_IMAGE_SIZE_CHANGE?????Â¼?Ê±???Ñ¸Ã±?Ê¶??1????Ê±???Ü½???fill/empty_this_buffer?È²??÷£¬µÈµ??Óµ?COMMON_DONE??OMX_CommandPortEnable???Â¼?????Ê±?Å»??????Ã»?0
	OMX_BOOL m_port_flushing;                                   //?Ë¿?bufferË¢?Â±?Ö¾Î»??Ä¬??Îªfalse?????Õµ?OMX_CommandFlush????Ê±????handle_command_flush???????í£¬?Ñ¸Ã±?Ê¶??1????Ê±???Ü½???fill/empty_this_buffer?È²??÷£¬µÈµ??Óµ?OMX_GENERATE_FLUSH_INPUT_DONE???Â¼?????Ê±?Å»??????Ã»?0


    //struct frame_info pic_info;               //??venc_driver_context???????????Ð¶??????????È¸ß¶???Ï¢???É·??????   (Ä¿Ç°?àµ±????????Ö¡??Ï¢)

    venc_user_buf **m_venc_bufhead;                 //?????Ú¶Ô±?×¼m_omx_bufhead?Ä²???buffer??
    
} OMX_PORT_PRIVATE;

//component private for omx                                     //??????Ë½?Ð½á¹¹?å£¬Êµ??Ó¦?Ã¾??ó²¿·Ö¶????????á¹¹?å£¬???Ð°?????×¼?????Ðµ?OMX_COMPONENTTYPE????????Ö¸??
typedef struct OMX_COMPONENT_PRIVATE {
	pthread_mutex_t m_lock;                                     //????Á¿???Ú¶Ô¹?????Ô´?Ä¶?Ð´????Ê±??Ò»??Òª?Ã»???Á¿???Ô±??????????Ä¹?????Ô´??Òª??:???????Ð£??ÜµÀ¶?Ð´??
	OMX_COMPONENTTYPE *m_pcomp;                                 //?????á¹¹??
	OMX_STATETYPE m_state;                                      //????×´Ì¬
	OMX_U32 m_flags;                                            //Ã¿Ò»Î»??Ó¦??flags_bit_positions?Ð¶??????Â¼?

	OMX_VIDEO_CODINGTYPE m_encoder_fmt;                         //??codec_info??Ó¦
	OMX_S8 m_role[OMX_MAX_STRINGNAME_SIZE];                     //???????????Ö±?Ê¶
    OMX_S8 m_comp_name[OMX_MAX_STRINGNAME_SIZE];                //??????????Ö¸??
	OMX_PTR m_app_data;                                         //???â²¿Ó¦?Ã³???APP????À´??Ò»???????????Ú¸?APP???Ö²?Í¬??component????Ó¦?Ã³???????OMX_GetHandleÊ±???Øµ??????á¹¹??Ö¸??Ò»??????
	OMX_CALLBACKTYPE m_cb;                                      //???â²¿Ó¦?Ã³???APP????À´?Øµ?????Ö¸?ë£¬??Ó¦?Ã³???????OMX_GetHandleÊ±??????m_app_data?Øµ??????á¹¹??Ö¸??Ò»??????

	OMX_TICKS m_pre_timestamp;                                  //pts Ê±????

	OMX_PORT_PRIVATE m_port[MAX_PORT_NUM];                      //port??Ë½?Ð½á¹¹                    
	OMX_BOOL m_use_native_buf;                                  //??????buffer??Ê¶????get/set_parameter?? OMX_GoogleIndexGetAndroidNativeBufferUsage = OMX_IndexVendorStartUnused + 3 ?Ð¶Ï·?Ö§??Ó¦??

	pthread_t msg_thread_id;                                    //??Ï¢?ß³?     ->write
	pthread_t event_thread_id;                                  //?Â¼??????ß³? ->read

	volatile OMX_BOOL event_thread_exit;                                 //?Â¼??????ß³??Ë³???Ö¾
	volatile OMX_BOOL msg_thread_exit;                                   ////??Ï¢?ß³??Ë³???Ö¾

    
	venc_drv_context drv_ctx;         //??ÎªComponent??Ë½?Ð½á¹¹????????omx_venc_drv.h?Ð°??????????è±¸?Ä¼???Ê¶???Å¡???????Í¨??????
	OMX_S32 m_pipe_in;                              //read this pipe
	OMX_S32 m_pipe_out;                             //write this pipe

	sem_t m_async_sem;                          //?ì²½?Åº?Á¿ ?????Ú¶?È¡Í¨??Ê±???Åº?Á¿????
	sem_t m_cmd_lock;                           //?????Åº?Á¿ (?àµ±????) ??

	omx_event_queue m_ftb_q;                    //???????Ý¶???           /*×¢??:Ã¿??Ð´??????Ö®???Ô¶????Ô¹ÜµÀ½?????Ó¦??Ð´?????Â¼??????ß³??Ð¶Ô¹ÜµÀ½??Ð¶Á²??÷£¬¶Á³???Ï¢????????????????*/
	omx_event_queue m_cmd_q;                    //????????
	omx_event_queue m_etb_q;                    //????Ô´????       

	//allocator_handle_t allocator_handle;        //?????Ú´æ£¬?Ãµ?IOH?è±¸Ê±?????Ú¼?Â¼ION????~ 
}OMX_COMPONENT_PRIVATE;

/*==========================================================================*/
// bit operation functions
static inline void bit_set(OMX_U32 *addr, OMX_U32 nr)                          // ?????Ýµ?Ä³Ò»Î»????Îª 1 (?Ãº?????64Î»Í¬????Ð§)
{
	addr[nr / BITS_PER_LONG] |= (1 << (nr % BITS_PER_LONG));
}

static inline void bit_clear(OMX_U32 *addr, OMX_U32 nr)                         // ?????Ýµ?Ä³Ò»Î»????Îª??0 (?Ãº?????64Î»Í¬????Ð§)
{
	addr[nr / BITS_PER_LONG] &= ~((OMX_U32)(1 << (nr % BITS_PER_LONG)));
}

static inline OMX_S32 bit_present(const OMX_U32 *addr, OMX_U32 nr)         // ?Ð¶?????Ä³Ò»Î»?Ç·?Îª 1;????Îª1,?ò·µ»?1?????ò·µ»?0 (?Ãº?????64Î»Í¬????Ð§)
{
	return ((1 << (nr % BITS_PER_LONG)) &
		(((OMX_U32 *)addr)[nr / BITS_PER_LONG])) != 0;
}

static inline OMX_S32 bit_absent(const OMX_U32 *addr, OMX_U32 nr)          // ?Ð¶?????Ä³Ò»Î»?Ç·?Îª 0??????Îª0,?ò·µ»?1?????ò·µ»?0
{
	return !bit_present(addr, nr);
}

#endif // __OMX_VENC_H__
